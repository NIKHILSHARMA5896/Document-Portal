name: CI/CD to ECS Fargate
on:
  workflow_run:
    workflows: ["Run Unit Tests"]   # Match the name in your ci.yaml
    types:
      - completed
env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: documentportal
  ECS_SERVICE: document-portal-service
  ECS_CLUSTER: document-portal-cluster
  ECS_TASK_DEFINITION: .github/workflows/task_definition.json
  CONTAINER_NAME: document-portal-container

permissions:
  id-token: write
  contents: read

jobs:
  check-status:
    runs-on: ubuntu-latest
    if: ${{github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main'}}
    steps:
      - name: CI passed on main branch
        run: echo "CI passed on main branch, proceeding to build and deploy."

  # -------------------------------
  # 1. Build & Push Docker Image
  # -------------------------------
  build-and-push:
    name: Build & Push Docker Image
    needs: [check-status]
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.build-image.outputs.image }}
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV
          docker build -t $IMAGE_URI .
          docker push $IMAGE_URI
          echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT

  # -------------------------------
  # 2. Deploy to ECS
  # -------------------------------
  deploy:
    name: Deploy to ECS Fargate
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Render Task Definition
        id: render-task
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ${{ env.ECS_TASK_DEFINITION }}
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ needs.build-and-push.outputs.image }}

      - name: Print Rendered Task
        run: cat ${{ steps.render-task.outputs.task-definition }}

      - name: Check if ECS Service exists and create if needed
        id: check-service
        run: |
          # Check if service exists
          SERVICE_EXISTS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].serviceName' \
            --output text 2>/dev/null || echo "None")
          
          if [ "$SERVICE_EXISTS" = "None" ] || [ "$SERVICE_EXISTS" = "" ]; then
            echo "Service doesn't exist, creating it..."
            
            # Get default VPC and subnets (you may want to specify your own)
            VPC_ID=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" --query 'Vpcs[0].VpcId' --output text)
            SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[0:2].SubnetId' --output text | tr '\t' ',')
            
            # Get or create security group
            SG_ID=$(aws ec2 describe-security-groups \
              --filters "Name=group-name,Values=document-portal-sg" "Name=vpc-id,Values=$VPC_ID" \
              --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
            
            if [ "$SG_ID" = "None" ] || [ "$SG_ID" = "" ]; then
              echo "Creating security group..."
              SG_ID=$(aws ec2 create-security-group \
                --group-name document-portal-sg \
                --description "Security group for document portal" \
                --vpc-id $VPC_ID \
                --query 'GroupId' --output text)
              
              # Allow inbound traffic on port 8080
              aws ec2 authorize-security-group-ingress \
                --group-id $SG_ID \
                --protocol tcp \
                --port 8080 \
                --cidr 0.0.0.0/0
              
              # Allow all outbound traffic
              aws ec2 authorize-security-group-egress \
                --group-id $SG_ID \
                --protocol -1 \
                --cidr 0.0.0.0/0 2>/dev/null || true
            fi
            
            # Register task definition first
            aws ecs register-task-definition \
              --cli-input-json file://${{ steps.render-task.outputs.task-definition }}
            
            # Create the service
            aws ecs create-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service-name ${{ env.ECS_SERVICE }} \
              --task-definition documentportaltd \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SG_ID],assignPublicIp=ENABLED}" \
              --enable-execute-command
            
            echo "service_created=true" >> $GITHUB_OUTPUT
          else
            echo "Service exists: $SERVICE_EXISTS"
            echo "service_created=false" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to ECS (Update existing service)
        if: steps.check-service.outputs.service_created == 'false'
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.render-task.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Wait for new service to be stable
        if: steps.check-service.outputs.service_created == 'true'
        run: |
          echo "Waiting for newly created service to become stable..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}

      - name: Done!
        run: echo "Deployed to ECS Fargate Successfully"